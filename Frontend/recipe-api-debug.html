<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recipe API Debug - ChopSmo</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            max-width: 900px; 
            margin: 50px auto; 
            padding: 20px; 
            background: #f8f9fa;
        }
        .debug-container { 
            background: white; 
            padding: 30px; 
            border-radius: 10px; 
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .recipe-debug { 
            margin: 20px 0; 
            padding: 20px; 
            border: 2px solid #ddd; 
            border-radius: 8px;
            background: #fafafa;
        }
        .field-debug { 
            margin: 10px 0; 
            padding: 10px; 
            background: #e8f4f8; 
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
        }
        .test-btn { 
            background: #ff6b35; 
            color: white; 
            border: none; 
            padding: 12px 24px; 
            border-radius: 6px; 
            cursor: pointer; 
            font-size: 16px;
            margin: 5px;
        }
        .test-btn:hover { background: #e55a2b; }
        .status { 
            padding: 10px; 
            margin: 10px 0; 
            border-radius: 4px; 
            font-weight: bold;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.info { background: #cce5ff; color: #004085; }
        .recipe-input { 
            width: 100px; 
            padding: 8px; 
            border: 2px solid #ddd; 
            border-radius: 4px; 
            margin: 0 10px;
        }
    </style>
</head>
<body>
    <div class="debug-container">
        <h2>üîç Recipe API Field Debug Tool</h2>
        <p>This tool fetches actual recipe data and shows all available fields to debug instruction detection</p>
        
        <div class="recipe-debug">
            <h3>üì° Fetch Recipe Data</h3>
            <label>Recipe ID: </label>
            <input type="number" id="recipeId" class="recipe-input" value="1" min="1">
            <button onclick="fetchRecipeData()" class="test-btn">Fetch Recipe</button>
            <button onclick="fetchAllRecipes()" class="test-btn">Fetch All Recipes</button>
            <button onclick="clearResults()" class="test-btn" style="background: #6c757d;">Clear</button>
        </div>
        
        <div id="status"></div>
        <div id="results" style="display: none;">
            <h3>üìù Recipe Data Analysis</h3>
            <div id="dataContent"></div>
        </div>
    </div>

    <script>
        const API_BASE = 'https://njoya.pythonanywhere.com/api';
        
        function showStatus(message, type = 'info') {
            document.getElementById('status').innerHTML = `<div class="status ${type}">${message}</div>`;
        }
        
        function showResults(html) {
            const resultsDiv = document.getElementById('results');
            resultsDiv.innerHTML = `<h3>üìù Recipe Data Analysis</h3><div id="dataContent">${html}</div>`;
            resultsDiv.style.display = 'block';
        }
        
        function clearResults() {
            document.getElementById('results').style.display = 'none';
            document.getElementById('status').innerHTML = '';
        }
        
        async function fetchRecipeData() {
            const recipeId = document.getElementById('recipeId').value || '1';
            showStatus(`üì° Fetching recipe ID: ${recipeId}...`, 'info');
            
            try {
                const response = await fetch(`${API_BASE}/recipes/${recipeId}/`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(localStorage.getItem('authToken') && {
                            'Authorization': `Token ${localStorage.getItem('authToken')}`
                        })
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const recipe = await response.json();
                console.log('üìù Recipe data:', recipe);
                
                analyzeRecipeFields(recipe);
                
            } catch (error) {
                console.error('‚ùå Fetch error:', error);
                showStatus(`‚ùå Failed to fetch recipe: ${error.message}`, 'error');
            }
        }
        
        async function fetchAllRecipes() {
            showStatus('üì° Fetching all recipes...', 'info');
            
            try {
                const response = await fetch(`${API_BASE}/recipes/`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        ...(localStorage.getItem('authToken') && {
                            'Authorization': `Token ${localStorage.getItem('authToken')}`
                        })
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                const recipes = Array.isArray(data) ? data : (data.results || []);
                
                console.log('üìù All recipes:', recipes);
                
                if (recipes.length > 0) {
                    analyzeMultipleRecipes(recipes);
                } else {
                    showStatus('‚ö†Ô∏è No recipes found', 'error');
                }
                
            } catch (error) {
                console.error('‚ùå Fetch error:', error);
                showStatus(`‚ùå Failed to fetch recipes: ${error.message}`, 'error');
            }
        }
        
        function analyzeRecipeFields(recipe) {
            showStatus('‚úÖ Recipe fetched successfully - analyzing fields...', 'success');
            
            const allFields = Object.keys(recipe);
            const textFields = allFields.filter(field => 
                typeof recipe[field] === 'string' && recipe[field].length > 20
            );
            
            let html = `
                <div class="field-debug">
                    <strong>Recipe ID:</strong> ${recipe.id || 'Unknown'}<br>
                    <strong>Title:</strong> ${recipe.title || recipe.name || 'Unknown'}<br>
                    <strong>All Fields:</strong> ${allFields.join(', ')}
                </div>
            `;
            
            // Check specific instruction fields
            const instructionFields = ['instructions', 'method', 'directions', 'preparation', 'steps'];
            
            html += '<h4>üîç Instruction Field Analysis:</h4>';
            
            for (const field of instructionFields) {
                if (recipe[field]) {
                    html += `
                        <div class="field-debug">
                            <strong>${field}:</strong><br>
                            ${recipe[field]}<br>
                            <em>Type: ${typeof recipe[field]}, Length: ${recipe[field].length || 'N/A'}</em>
                        </div>
                    `;
                }
            }
            
            // Check description and other text fields
            html += '<h4>üìù Other Text Fields:</h4>';
            
            for (const field of textFields) {
                if (!instructionFields.includes(field)) {
                    const content = recipe[field];
                    const isLikelyInstructions = looksLikeInstructions(content);
                    
                    html += `
                        <div class="field-debug" style="background: ${isLikelyInstructions ? '#fff3cd' : '#e8f4f8'}">
                            <strong>${field} ${isLikelyInstructions ? '(‚ö†Ô∏è Looks like instructions!)' : ''}:</strong><br>
                            ${content.substring(0, 200)}${content.length > 200 ? '...' : ''}<br>
                            <em>Type: ${typeof content}, Length: ${content.length}</em>
                        </div>
                    `;
                }
            }
            
            showResults(html);
        }
        
        function analyzeMultipleRecipes(recipes) {
            showStatus(`‚úÖ Fetched ${recipes.length} recipes - analyzing patterns...`, 'success');
            
            let html = `<div class="field-debug"><strong>Total Recipes:</strong> ${recipes.length}</div>`;
            
            // Analyze field presence
            const fieldCounts = {};
            const instructionFieldCounts = {};
            const instructionFields = ['instructions', 'method', 'directions', 'preparation', 'steps'];
            
            recipes.forEach(recipe => {
                Object.keys(recipe).forEach(field => {
                    fieldCounts[field] = (fieldCounts[field] || 0) + 1;
                    
                    if (instructionFields.includes(field) && recipe[field]) {
                        instructionFieldCounts[field] = (instructionFieldCounts[field] || 0) + 1;
                    }
                });
                
                // Check if description contains instructions
                if (recipe.description && looksLikeInstructions(recipe.description)) {
                    instructionFieldCounts['description (instructions detected)'] = 
                        (instructionFieldCounts['description (instructions detected)'] || 0) + 1;
                }
            });
            
            html += '<h4>üìä Instruction Field Statistics:</h4>';
            for (const [field, count] of Object.entries(instructionFieldCounts)) {
                html += `
                    <div class="field-debug">
                        <strong>${field}:</strong> ${count} recipes (${Math.round(count/recipes.length*100)}%)
                    </div>
                `;
            }
            
            // Show sample recipes with different instruction patterns
            html += '<h4>üîç Sample Recipes by Pattern:</h4>';
            
            const samplesWithInstructions = recipes.filter(r => r.instructions).slice(0, 2);
            const samplesWithMethod = recipes.filter(r => r.method && !r.instructions).slice(0, 2);
            const samplesWithDescriptionInstructions = recipes.filter(r => 
                !r.instructions && !r.method && r.description && looksLikeInstructions(r.description)
            ).slice(0, 2);
            
            if (samplesWithInstructions.length > 0) {
                html += '<h5>‚úÖ Has Instructions Field:</h5>';
                samplesWithInstructions.forEach(recipe => {
                    html += `
                        <div class="field-debug">
                            <strong>${recipe.title || recipe.name} (ID: ${recipe.id})</strong><br>
                            ${recipe.instructions.substring(0, 150)}...
                        </div>
                    `;
                });
            }
            
            if (samplesWithDescriptionInstructions.length > 0) {
                html += '<h5>‚ö†Ô∏è Instructions in Description:</h5>';
                samplesWithDescriptionInstructions.forEach(recipe => {
                    html += `
                        <div class="field-debug" style="background: #fff3cd">
                            <strong>${recipe.title || recipe.name} (ID: ${recipe.id})</strong><br>
                            ${recipe.description.substring(0, 150)}...
                        </div>
                    `;
                });
            }
            
            showResults(html);
        }
        
        function looksLikeInstructions(text) {
            if (!text || typeof text !== 'string' || text.trim().length < 20) {
                return false;
            }
            
            const instructionIndicators = [
                /\b\d+\.\s/g,
                /step\s+\d+/g,
                /\b(heat|cook|add|mix|stir|boil|simmer|fry|bake|saut√©|chop|dice|slice|season|serve|pour|combine|whisk|blend|marinate|grill|roast|steam)\b/g,
                /\b\d+\s*(minutes?|mins?|hours?|hrs?)\b/g,
                /until\s+(golden|tender|cooked|done|soft|crispy)/g,
                /over\s+(medium|high|low)\s+heat/g,
                /in\s+a\s+(pan|pot|bowl|skillet)/g
            ];
            
            let indicatorCount = 0;
            for (const pattern of instructionIndicators) {
                const matches = text.match(pattern);
                if (matches) {
                    indicatorCount += matches.length;
                }
            }
            
            const hasMultipleSteps = (text.match(/\b\d+\.\s/g) || []).length >= 2;
            const hasCookingVerbs = indicatorCount >= 3;
            
            return hasMultipleSteps || hasCookingVerbs;
        }
        
        console.log('üîç Recipe API Debug Tool loaded');
    </script>
</body>
</html>
